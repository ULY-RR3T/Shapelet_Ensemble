import matplotlib.pyplot as plt
import seaborn as sns
import os
from lib.config import *
from lib.data import *
import pandas as pd
from tqdm import tqdm
from matplotlib.offsetbox import AnchoredText

sns.set()

def extract_curr_prediction():
    """ Extracts the current result of the model defined in config

    :return: List(series_1,series_2,series_3,series_4) where series_i represents the i-week ahead foreast
    """
    model_name = type(Model).__name__
    lookback_period = Lookback_Period
    k_cluster = K_cluster
    target_dir = f"{result_output_dir}/{model_name}_{lookback_period}_{k_cluster}"
    files = [f for f in os.listdir(target_dir) if os.path.isfile(f"{target_dir}/{f}")]
    rslt_series_tempalte = pd.Series(index=get_all_states(),dtype=np.float64).to_frame()
    rslt = [rslt_series_tempalte.copy() for _ in range(4)]
    other_rslts = get_all_model_predictions()
    for file in files:
        curr_df = pd.read_csv(f"{target_dir}/{file}")
        for i,day in enumerate(curr_df.columns[1:]):
            rslt[i] = rslt[i].join(curr_df.set_index('State').iloc[:,i])
    for i in range(4):
        rslt[i] = rslt[i].iloc[:,1:]

def error_plot(error=True,config=None):

    # Extract and convert the csv files generated by model into n-weeks ahead series
    curr_pred = extract_curr_prediction()

    # Get all dates and states covered by the current predictions
    all_dates = sorted(list(set.union(*[set(curr_pred[i].columns.astype(np.int64).values) for i in range(4)])))
    all_states = sorted(list(set.union(*[set(curr_pred[i].index.values) for i in range(4)])))

    # Get ground truth for all dates with valid prediction from our curr_pred
    truth = get_ground_truth_array(all_dates)

    err_diff_sum = 0

    # Get predictions from all other models
    other_preds = get_all_model_predictions()

    for state in tqdm(all_states):
        state_fault = False
        fig,axs = plt.subplots(2,2,figsize=(15,15))
        for i in range(4):
            df_plot = curr_pred[i]
            df_plot.columns = df_plot.columns.astype(np.int64)
            df_plot = df_plot.loc[state].T.to_frame().join(truth.loc[state].T,rsuffix='_Truth').sort_index()
            other_rslts_curr = [other_preds[key][i].loc[state].rename(key) for key in other_preds.keys()
                                if (len(other_preds[key]) >= i+1) and (state in other_preds[key][i].index)]
            for j in range(len(other_rslts_curr)):
                other_rslts_curr[j] = other_rslts_curr[j][~other_rslts_curr[j].index.duplicated(keep='first')]

            plot_title = f"Forecast for State {state} for {i+1} Weeks Ahead"
            overall_rslt = pd.concat(other_rslts_curr,axis=1).sort_index()
            median_series = overall_rslt.median(axis=1).rename('Generated Median')
            try:
                median_series = median_series.to_frame().join(overall_rslt['COVID_Hub_Trained_Ensemble'])
            except:
                warnings.warn(f"No data for COVID_Hub_Trained_Ensemble for state {state}")
                state_fault = True
                break
            if error:
                median_series = pd.concat([median_series,df_plot.iloc[:,1]],axis=1,join='inner')
                overall_rslt = pd.concat([overall_rslt,df_plot.iloc[:,1]],axis=1,join='inner')
                overall_rslt = overall_rslt.iloc[:,:-1].subtract(overall_rslt.iloc[:,-1],axis=0).abs()
                median_series = median_series.iloc[:,:-1].subtract(median_series.iloc[:,-1],axis=0).abs()
                df_plot = pd.Series(np.abs(df_plot.iloc[:,1] - df_plot.iloc[:,0]),index=df_plot.index).abs().rename('Method')
                plot_title = f"Error for State {state} for {i + 1} Weeks Ahead"
                method_error_mean = df_plot.mean()
                generated_median_erorr_mean = median_series.iloc[:,0].mean()
                trained_median_erorr_mean = median_series.iloc[:,1].mean()
            if state_fault:
                continue
            median_series.plot(ax=axs.ravel()[i],color=['orangered','orange']).legend(loc='upper left')
            df_plot.plot(ax=axs.ravel()[i],title=plot_title,color=['steelblue','green']).legend(loc='upper left')
            overall_rslt.plot(ax=axs.ravel()[i],title=plot_title,alpha=0.1,legend=False)
            if error:
                curr_naive_err_diff = method_error_mean-generated_median_erorr_mean
                curr_trained_err_diff = method_error_mean-trained_median_erorr_mean
                err_diff_sum += curr_naive_err_diff
                anchored_text = AnchoredText(f"Method: {round(method_error_mean)}\n"
                                             f"Generated Median:{round(generated_median_erorr_mean)}\n"
                                             f"Trained Median:{round(trained_median_erorr_mean)}\n"
                                             f"Difference Naive:{round(curr_naive_err_diff)}\n"
                                             f"Difference Trained:{round(curr_trained_err_diff)}", loc='center right')
                axs.ravel()[i].add_artist(anchored_text)
        if error:
            out_folder = folder(f"{result_output_dir}/{model_name}_{lookback_period}_{k_cluster}/plots/error")
        else:
            out_folder = folder(f"{result_output_dir}/{model_name}_{lookback_period}_{k_cluster}/plots/forecast")
        plt.show()
        fig.savefig(f"{out_folder}/{state}.png",dpi=300)
        print(f"{out_folder}/{state}.png")
    out_file = open(f"{result_output_dir}/rslt_summary.txt", 'a')
    out_file.write(f"{model_name}_{lookback_period}_{k_cluster} {round(method_error_mean)} \n")

